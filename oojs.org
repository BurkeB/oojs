* Re-examining Object Oriented Programming with JavaScript

#+BEGIN_QUOTE
In this post I'll define a rudimentary object system written in
JavaScript.  Of course JavaScript already *has* a rudimentary object
system.  However, I think it suffers from a confusing
conglomeration of competing ideas.  I think many people will be
surprised at how elegantly JavaScript can define an object system with
no new syntax.  While defining the system I hope to provoke thoughts about
what it means to be "Object Oriented".
#+END_QUOTE

One day at work, we were discussing languages that we enjoyed working
with.  Some people expressed surprise that very near the top of my
preferences I listed JavaScript.  It's a language that many people
use, but often only when they have no other choice.  Similarly,
I frequently bump into blogs on the internet expressing a distaste
(verging on disgust, in some cases) for object oriented programming (OOP).

If you hang around in the programming industry long enough you may
notice a common occurrence.  Sometimes someone has a seed of an idea.
It is not fully formed yet, but it has a lot of promise.  They work on
the idea for a while and word spreads.  Eventually it becomes well
known, with many people experimenting with it.  Evolution of the idea follows
several paths, each proponent injecting their own ideas, both good and
bad until the most widespread versions of the idea no longer closely
match the original.  Often the idea is derided as horrible, using
evidence gathered from the popular views that no longer match the
original.

In that vein, you may be familiar with definitions of object oriented
programming (OOP) that involve things like "inheritance",
"polymorphism", "encapsulation", etc, etc.  However, in my own career
dominated mostly by object oriented programming, I have found that
these definitions fall short.  Indeed, all of those things are present
in object oriented systems, but they aren't the benefits that I
actually want from OOP.  Ideally, I'm just after better cohesion with
less unnecessary coupling in my code.  As a part of this, I value
being able to write generic code when it improves cohesion.

OOP evolved from several different backgrounds, which is, I think, one
of the reasons why our view is so muddled now. We have conflated a
bunch of competing ideas, not all of which are compatible with one
another.  For the purposes of this post I'm going to fall back on a
[[http://www.purl.org/stefan_ram/pub/doc_kay_oop_en][very simple
description of OO]] from Alan Kay, one of the original progenitors of
OOP:

#+BEGIN_QUOTE
OOP to me means only messaging, local retention and protection and
hiding of state-process, and extreme late-binding of all things. It
can be done in Smalltalk and in LISP. There are possibly other
systems in which this is possible, but I'm not aware of them. -- Alan Kay
#+END_QUOTE

He wrote that email in 2003 and I wonder if he dismissed JavaScript
out of hand.  I know at that time, I would have done the same.  Now I
wonder if we can't build something that comes close to matching his
view using only very basic JavaScript.

In this post I'll define a rudimentary object system written in
JavaScript.  Of course JavaScript already *has* a rudimentary object
system.  However, I think it suffers from the aforementioned confusing
conglomeration of competing ideas.  I think many people will be
surprised at how elegantly JavaScript can define an object system with
no new syntax.

I should point out that I am not suggesting that one actually *use*
this system.  It is just an exploration of ideas.  Similarly I am not
attempting to sway the reader into accepting JavaScript or even OOP as
a tool that they should use.  I am simply hoping to view the problem
from a different point of view.  If it proves interesting, then I will
be more than satisfied.

We're only going to use a few basic features of JavaScript in this
endeavour.  I'll use ES6 notation, because I find it more convenient,
but the vast majority of what I'm doing can be done just as easily (if
considerably more verbosely) in earlier versions of the language.
I'll point out any potential differences along the way. Even if you
have not used JavaScript extensively before, we are using so few
facilities of what makes up modern JavaScript, I think it will be
fairly easy to understand.

** Immutability and Idempotence

It may be surprising to start by looking at immutability.  There are a
couple of reasons why I feel it is necessary to do so.  Many
criticisms of OOP come from programmers who have experience with pure
functional languages.  For some reason, they believe that mutability
is inherent to OOP.  I want to dispell that notion.  It is just as
easy to write an object system using immutable data structures and
pure functions as it is to write one with mutable data structures.

Having just made that comment, I have to admit that the vast majority
of OO programming languages make it very difficult to write immutable
code.  The issues that you have to keep in mind are not obvious.  For
that reason, many (most?) object oriented programmers do not
understand the cost of mutability in their code.  As we'll see, it's
not always easy to contain that mutability, which leads to code that
is more difficult to reason about than necessary.

Finally, JavaScript has made a few language design choices that impact
how we can write immutable code.  I think it is worth going over these
as some of them may be surprising unless you understand JavaScript
very well.  This section will also serve as an introduction to all of
the JavaScript facilities we will use to build the object system.

*** References and Values

JavaScript is a garbage collected language.  What that means is that
the programmer does not explicitly allocate memory.  A separate
facility in the run-time system occasionally looks for data that is no
longer being used and frees the memory.  All variables in JavaScript are
references that point to values (usually allocated on the heap).

Early versions of JavaScript had only mutable variables.  That is, you
can change the value that they point to.  ~var~ declares a mutable
variable with function scope (it can be used anywhere inside the
enclosing function).  While the variable is mutable, the value that it
references is often immutable (it can't be modified).  Here is an
example:

#+BEGIN_SRC js
  var a = 5;
  var b = a;
  a += 5;

  return({a: a, b: b});
#+END_SRC
#+BEGIN_SRC js
> { a: 10, b: 5 }
#+END_SRC

Another way to think about this is that we can point our variable (via
assignment) to any value we want, but the value itself can not
change.  The value ~5~ does not suddenly become ~6~, but our variable can
point to ~5~ or ~6~ (or any other value).  In this way, the variable is
mutable (can be changed) while the value is immutable (can not be
changed).  You may be forgiven for thinking this is obvious -- where
would we be if ~5~ suddenly became ~6~?  However, some kinds of
values *can* be changed (which we will see later).

ES6 introduced 2 other kinds of variables: ~let~ and ~const~.  ~let~
variables are mutable, but block scoped and ~const~ variables are
immutable while also being block scoped.  "Block scoped" means that
you can use the variable anywhere within the block in which it is
declared, but not outside.  Blocks are generally defined with ~{}~
characters.  An example might be an ~if~ statement.  With ~const~
variables, you can not change the reference after they have been
assigned once.  If you only use ~const~ variables that point to
immutable values, then you can be sure that everything is immutable.

Most values in JavaScript are immutable.  Surprisingly, even string
values are immutable in JavaScript (although, unfortunately it doesn't
throw an error if you try to mutate them).  For example:

#+BEGIN_SRC js
  var a = "bar";
  a[2] = 'z';

  return({a: a});
#+END_SRC
#+BEGIN_SRC js
> { a: 'bar' }
#+END_SRC

Even constructed strings are immutable.  For example adding two
strings together returns an immutable string.  This surprised me
slightly when I looked into it, but there are some performance reasons
why immutable strings are beneficial.

There are only a few value types that are mutable in Javascript.  Anyone
who has worked with immutable data structures before knows that they
can be tricky to work with.  For performance reasons, it's often
helpful to have mutable arrays, and JavaScript's arrays are mutable.

#+BEGIN_SRC js
  var a = [1, 2, 3];
  var b = a;

  a[2] = 4;

  return({a: a, b: b});
#+END_SRC
#+BEGIN_SRC js
> { a: [ 1, 2, 4 ], b: [ 1, 2, 4 ] }
#+END_SRC

The other main type of value that is mutable in JavaScript is the
"object".  An "object" is not as special as you might imagine from its
name.  In other languages it would be called a "dictionary", "hash",
"record" or "struct".  The name is quite unfortunate because it
conflates the OO notion of "object" with something that can be used to
construct an object.  To avoid that confusion, I'm going to call it a
"dictionary" in this post, which is what Smalltalk calls it.  After
all, JavaScript was originally intended to be similar to Smalltalk, so
I think it's appropriate.  I apologise in advance if you find it
confusing.

Here is an example of the mutability of dictionaries:

#+BEGIN_SRC js
  const a = {foo: 1};
  const b = a;
  a.foo = 2;

  return({a: a, b: b});
#+END_SRC
#+BEGIN_SRC js
> { a: { foo: 2 }, b: { foo: 2 } }
#+END_SRC

It is important to understand that even though the *variables* ~a~ and
~b~ are immutable (const), the *values* that they point to are not.
Personally, I find the keywords pretty confusing, but as long are you
keep in mind that they refer to the *variable* you'll be fine.  It's
also important to realise that *assignment* points a variable to a
*new value*.  For example:

#+BEGIN_SRC js
  let a = {foo: 1};
  let b = a;
  a = {foo: 2};

  return({a: a, b: b});
#+END_SRC
#+BEGIN_SRC js
> { a: { foo: 2 }, b: { foo: 1 } }
#+END_SRC

*** Functions, Closures and Currying

In JavaScript, functions are "first class citizens".  In other words
a function is a value just like any other value.  Once a function has
been defined, you can't really modify it (just in the same way that
the value ~5~ can't suddenly become ~6~, one function can't suddenly
transform into a different function).

Here is an example:

#+BEGIN_SRC js
  let a = function add(x, y) { return x + y };
  let b = a;
  let result_a1 = a(1, 2);
  a = function subtract(x, y) { return x - y };
  let result_a2 = a(1, 2);
  let result_b = b(1, 2);

  return({a: a, b: b, result_a1: result_a1, result_a2: result_a2, result_b: result_b });
#+END_SRC
#+BEGIN_SRC js
> { a: [Function: subtract],
    b: [Function: add],
    result_a1: 3,
    result_a2: -1,
    result_b: 3 }
#+END_SRC

While admirably clear, this syntax is pretty awkward for using
functions in any more than a rudimentary way.  ES6 introduced a
notation for lambdas (unnamed functions) which is more convenient.  I
will be using it for the remainder of this post.  Of course the
downside is that lambdas have no name.  Here is the same code using
that notation:

#+BEGIN_SRC js
  let a = (x, y) => x + y;
  let b = a;
  let result_a1 = a(1, 2);
  a = (x, y) => x - y;
  let result_a2 = a(1, 2);
  let result_b = b(1, 2);

  return({a: a, b: b, result_a1: result_a1, result_a2: result_a2, result_b: result_b});
#+END_SRC
#+BEGIN_SRC js
> { a: [Function: a],
    b: [Function: a],
    result_a1: 3,
    result_a2: -1,
    result_b: 3 }
#+END_SRC

Not only can functions be assigned to variables, they can also be
passed to and returned from functions.  This leads us to another
feature, which is common in many popular languages today: closures.
While common today, when it was first introduced it was a pretty
esoteric feature that was absent in most mainstream programming
languages. An example is probably the easiest way to describe a closure.

#+BEGIN_SRC js
  const add = (x) => {
    return (y) => x + y;
  };
  const inc = add(1);
  const add_two = add(2);

  return({inc_5: inc(5), add_two_to_6: add_two(6), inc_3: inc(3)});
#+END_SRC
#+BEGIN_SRC js
> { inc_5: 6, add_two_to_6: 8, inc_3: 4 }
#+END_SRC

What is happening here?  The function ~add~ takes a single parameter,
~x~, and returns a new function that takes a single parameter y.  The
function it returns adds ~x~ and ~y~ together.  The function returned
by ~add~ needs to remember ~x~, even though ~x~ is no longer in scope.
We say that the function returned by ~add~ "closes over ~x~".  That
function is known as a "closure".

It is important to understand that a closure remembers the value of
the variable *when it was constructed*, not when it was called.  So in
this case, ~inc~ always uses the value of ~1~ for ~x~, while ~add_two~
always uses the value of ~2~ for ~x~.  As long as the value is immutable,
it can not change.  However, you must beware if you close over a
dictionary (aka object) or array because they are *not*
immutable. Because this has serious consequences, we'll explore this
in more detail shortly.

In functional programming, this kind of construction is very popular.
Earlier we saw a definition of ~add~ that took 2 parameters (~x~ and
~y~).  Just to remind you:

#+BEGIN_SRC js
  const add = (x, y) => x + y;
#+END_SRC

We also had a version that returned a closure for dealing with the
second paramer, ~y~:
#+BEGIN_SRC js
  const add = (x) => {
    return (y) => x + y;
  };
#+END_SRC

ES6 allows you to omit the parentheses in the parameter list
if there is exactly one parameter.  You can also omit the braces and
~return~ statement in the body if it is composed of exactly one
expression.  With that we can refactor the second version
into something that more closely resembles what you would find in a
functional programming language:

#+BEGIN_SRC js
  const add = x => y =>
    x + y;
#+END_SRC

Before ES6 you would have to write this as:

#+BEGIN_SRC js
  var add = function(x) {
    return function(y) {
      return x + y;
    };
  };
#+END_SRC

The older form is easier to understand what it is doing under
the hood, but the first is dramatically easier to type and to reason
about, once you understand it.  For this reason, I will stick to the
newer, compressed ES6 style as much as possible.

Syntax aside, this is an example of "currying".  Every function that
can take 2 parameters can be converted into a function that takes 1
parameter and returns a closure that takes 1 parameter.  You can
extend that to functions with any number of parameters, but I will
leave that as an exercise for the reader.

The functions we defined earlier, ~inc~ and ~add_two~, are examples of
"partially applied functions".  "Partially applied" means that only
some of the parameters have been specified.  The result is a function that
allows you to specify the remaining parameters.  Just to remind you,
here's the definition of ~inc~ again:

#+BEGIN_SRC js
  const inc = add(1);
#+END_SRC

You'll notice that while ~inc~ is a function, we don't specify the
parameter in its definition.  This is called "point free form" in
functional programming languages.  While it takes some getting used
to, it can sometimes make the intent more clear: ~inc~ is equivalent to
adding one to something.

Note that we can specify all of the parameters to ~add~ if we want to,
although the syntax is slightly unfortunate in JavaScript (probably a
result of early demands to make it look like Java, even though it
operates differently under the hood):

#+BEGIN_SRC js
  const add = x => y =>
    x + y;
  const a = add(1)(3);

  return({a: a});
#+END_SRC
#+BEGIN_SRC js
> { a: 4 }
#+END_SRC

*** Idempotence

Earlier I mentioned that as long as the variables closed over in a
closure are immutable, they can't change value.  It is important to
understand, though, that function parameters are mutable in
JavaScript:

#+BEGIN_SRC js
  const foo = (x) => {
    x = x + 1;
    return x;
  };

  return({foo_4: foo(4)});
#+END_SRC
#+BEGIN_SRC js
> { foo_4: 5 }
#+END_SRC

Effectively, this makes closures mutable.  Consider the following:

#+BEGIN_SRC js
  const init = x => y => {
    x = x + y;
    return x;
  };
  const advance = init(0);

  return({
    a: advance(1),
    b: advance(1),
    c: advance(1),
    d: advance(1)
  });
#+END_SRC
#+BEGIN_SRC js
: { a: 1, b: 2, c: 3, d: 4 }
#+END_SRC

Every time you call ~advance~ it increments ~x~ the appropriate
amount.  This value is stored as state in the closure.  While you
can't change the function after it has been defined, its operation
*can* change because the variables that are closed over are mutable.

A function that always returns the same value when given the same
parameters is called *idempotent*.  Idempotent functions are *much*
easier to reason about because we don't have consider any previous
state.  Especially when debugging a problem, you don't always know
what state caused a problem, so whenever possible we want to write
idempotent functions.

We have to be especially careful when we close over mutable values.
Even if you don't reassign the closed over variable, the closure can be
mutated simply by mutating the value.  Here is an example:

#+BEGIN_SRC js
  const init = x => y =>
    x.count + y;
  const dict = {count: 0};
  const add_to_count = init(dict);

  const a = add_to_count(1);
  const b = add_to_count(1);
  dict.count = 5;
  const c = add_to_count(1);

  return({a: a, b:b, c:c});
#+END_SRC
#+BEGIN_SRC js
: { a: 1, b: 1, c: 6 }
#+END_SRC

Even though we never reassigned the variable ~x~, the closure is not
idempotent simply because ~x~ was mutable.  This is an important
lesson: mutability is a bit like a disease.  One piece of mutable
data can spread the mutability to other data structures if you do not
take care to isolate it.  This is not a problem with OOP, it is just
the nature of programming.

** Building a Rudimentary Object System

With just these facilities, we can now build a rudimentary object
system. The astute reader will notice by now that I have not really
discussed OO at all up until this point.  In fact, everything I've
talked about is really the basics of *functional* programming.  I hope
you can see that, if you are careful, JavaScript could make a pretty
good functional language.  How does that relate to the object oriented
paradigm?

*** Defining a Rectangle

First, I have to admit that this example is highly contrived.  One of
the worst problems of explanations of OOP is the use of toy problems
where real world issues rarely rear their ugly heads.  However, as I
stated in the introduction, my goal here is not to explain, or sell
you on OOP.  I merely want to look at the issue from a different angle
and hopefully start a thought process for carrying it on further.

With that disclaimer, let's start in a kind of unorthodoxed way.  I
think most people would start their object oriented modelling by
defining what a rectangle looks like: i.e. what a struct or dictionary
of it would look like.  However, Alan Kay doesn't talk at all about
the structure of objects in his very concise definition.  He talks
about messaging, dealing with state, and late binding.  Let's start
with a function.

#+BEGIN_SRC js
  const area = (length, width) =>
    length * width;

  return({area_5_2: area(5, 2)});
#+END_SRC
#+BEGIN_SRC js
> { area_5_2: 10 }
#+END_SRC

This is not very exciting as it stands, but it gives us some insight
about rectangles: they have a length and a width.  Let's write another
function that explores other properties of rectangles.

#+BEGIN_SRC js
  const translate = (x, y, dx, dy) => {
    return { x: x + dx, y: y + dy };
  };

  return({translate_1_2_4_5: translate(1, 2, 4, 5)});
#+END_SRC
#+BEGIN_SRC js
> { translate_1_2_4_5: { x: 5, y: 7 } }
#+END_SRC

In this case, "translate" moves the rectangle to some other point on
the plane.  We have the "x" and "y" coordinates for the position of
the rectangle, and the amount we want to move in both the x and y
directions. It returns the position where we will move to.  In this
case, I'm returning a dictionary.  However, I'm not very happy with
this implementation.  The most glaring problem is that the position
I'm passing in (two numbers: "x" and "y") is not the same type as the
position I'm returning (a dictionary containing "x" and "y").

The other thing I notice upon reflecting on this code is that
"translate" is not strictly a behaviour of a rectangle.  It's a
behaviour of the point that represents the rectangle's position.
Let's back up and define that point before we go any further.

*** Create a Point "class"

Now the most obvious way to proceed is to represent a point as a
dictionary, exactly the way we did when returned the translated
position.  However, looking at Alan Kay's description of OOP, I'm not
convinced that this will bring us closer to his vision.  Is there a
different way of representing the object?  One of the clues might come
from the phrase "local retention ... of state-process".  We have
already seen a way to do that: closures.  Consider the following:

#+BEGIN_SRC js
  const Point = (x, y) => {
    return {
      translate: (dx, dy) =>
        Point(x + dx, y + dy)
    };
  };

  const point = Point(1, 2);

  return({translate_4_5: point.translate(4, 5)});
#+END_SRC
#+BEGIN_SRC js
> { translate_4_5: { translate: [Function: translate] } }
#+END_SRC

Let's just walk through this.  "Point" is a function that takes "x"
and "y" coordinates.  It returns a dictionary that contains a single
entry: "translate".  Translate contains a function that runs the
"Point" function, with updated coordinates.  If you are familiar with
OOP languages, you might recognise "Point" as being a constructor.

What's unusual is that we *don't seem to store the attributes of Point
anywhere!*  In reality, they *are* stored, but in the closure,
"translate".  The really interesting thing is that there is literally
no way for us to access the values stored in our Point object.  Even
when we dump the object, we just see that we have a dictionary
containing a function.  Let's amend this slightly.

#+BEGIN_SRC js
  const Point = (x, y) => {
    return {
      show: () => {
        return {x: x, y: y};
      },
      translate: (dx, dy) =>
        Point(x + dx, y + dy)
    };
  };

  const point = Point(1, 2);
  const translated = point.translate(4, 5);

  return({
    point: point.show(),
    translated: translated.show()
  });
#+END_SRC
#+BEGIN_SRC js
> { point: { x: 1, y: 2 }, translated: { x: 5, y: 7 } }
#+END_SRC

Now we've add an accessor that let's us inspect the private
attributes.  The interesting thing here is that our Point objects (at
least from the perspective of the attributes) is *still* immutable.
We can't change it.  For example:

#+BEGIN_SRC js
  const point = Point(1, 2);
  point.show().x = 42;

  return({point: point.show()});
#+END_SRC
#+BEGIN_SRC js
> { point: { x: 1, y: 2 } }
#+END_SRC

"show" returns a *copy* of the attributes, so there is still no way
for us to mutate the object.  In this way, I think we're a lot closer
to Alan Kay's description: "local retention and protection and
hiding of state-process".  Our state is hidden by default.  Even if we
show the values with an accessor, the state is still immutable.  Of
particular interest to me is that as long as we restrict ourselves to
a very basic subset of JavaScript, the code is also extremely easy to
write and read (apart from the ugly way one must return dictionaries).
It also requires no new syntax for the language.

What if we wanted a mutable Point object?

#+BEGIN_SRC js
  const Point = (x, y) => {
    return {
      show: () => {
        return {x: x, y: y};
      },
      setX: (new_x) =>
        x = new_x,
      setY: (new_y) =>
        y = new_y,
      translate: (dx, dy) =>
        Point(x + dx, y + dy)
    };
  };

  const point = Point(1, 2);
  point.setX(23);
  point.setY(42);

  return({
    point: point.show(),
  });
#+END_SRC
#+BEGIN_SRC js
> { point: { x: 23, y: 42 } }
#+END_SRC

This gives us a mutable point.  It works because parameters (and hence
the variables being closed over) are mutable in JavaScript.  All
things being equal, it's easier to reason about immutable data
structures than mutable ones, so for now we won't include those setters.

It interesting to consider that our Point "class" is just a function.
Although the approach to creating objects differs, this is one of the
things that appeals to me about Javascript's approach to OOP.  There
is no particular reason to create new syntax around something so
simple.  Just as in FP, the state in the system is simply the
application of parameters to a function.

Another interesting thing is that our "object" is just a dictionary of
closures -- in essence a dictionary of partially applied functions.
As you will see, we can use this fact to implement subtype
polymorphism extremely simply.  Although some would consider a
function as a perversion of the meaning of a "message", as long as the
binding is late enough, we should be able to fulfill Alan Kay's ideas.

*** Returning to Rectangle

Now that we've defined a Point class.  We can return to our problem of
translating a rectangle.  Let's write a Rectangle class in the same
fashion as the Point class.

#+BEGIN_SRC js
  const Point = (x, y) => {
    return {
      show: () => {
        return {x: x, y: y};
      },
      translate: (dx, dy) =>
        Point(x + dx, y + dy)
    };
  };

  const Rect = (pos, length, height) => {
    return {
      show: () => {
        return {pos: pos.show(), length: length, height: height};
      },
      area: () =>
        length * height,
      translate: (dx, dy) =>
        Rect(pos.translate(dx, dy), length, height)
    };
  };

  const rect = Rect(Point(1, 2), 4, 5);

  return({
    rect: rect.show(),
    area: rect.area(),
    translated: rect.translate(10, 20).show(),
  });
#+END_SRC
#+BEGIN_SRC js
> { rect: { pos: { x: 1, y: 2 }, length: 4, height: 5 },
    area: 20,
    translated: { pos: { x: 11, y: 22 }, length: 4, height: 5 } }
#+END_SRC
